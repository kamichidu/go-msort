// Auto generated code; DO NOT EDIT THIS FILE
package compare

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestInt(t *testing.T) {
	cases := []struct {
		V    int
		A, B int
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Int(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestIntPtr(t *testing.T) {
	to := func(v int) *int {
		return &v
	}
	cases := []struct {
		V    int
		A, B *int
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, IntPtr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestInt8(t *testing.T) {
	cases := []struct {
		V    int
		A, B int8
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Int8(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestInt8Ptr(t *testing.T) {
	to := func(v int8) *int8 {
		return &v
	}
	cases := []struct {
		V    int
		A, B *int8
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, Int8Ptr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestInt16(t *testing.T) {
	cases := []struct {
		V    int
		A, B int16
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Int16(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestInt16Ptr(t *testing.T) {
	to := func(v int16) *int16 {
		return &v
	}
	cases := []struct {
		V    int
		A, B *int16
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, Int16Ptr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestInt32(t *testing.T) {
	cases := []struct {
		V    int
		A, B int32
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Int32(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestInt32Ptr(t *testing.T) {
	to := func(v int32) *int32 {
		return &v
	}
	cases := []struct {
		V    int
		A, B *int32
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, Int32Ptr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestInt64(t *testing.T) {
	cases := []struct {
		V    int
		A, B int64
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Int64(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestInt64Ptr(t *testing.T) {
	to := func(v int64) *int64 {
		return &v
	}
	cases := []struct {
		V    int
		A, B *int64
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, Int64Ptr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestUint(t *testing.T) {
	cases := []struct {
		V    int
		A, B uint
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Uint(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestUintPtr(t *testing.T) {
	to := func(v uint) *uint {
		return &v
	}
	cases := []struct {
		V    int
		A, B *uint
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, UintPtr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestUint8(t *testing.T) {
	cases := []struct {
		V    int
		A, B uint8
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Uint8(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestUint8Ptr(t *testing.T) {
	to := func(v uint8) *uint8 {
		return &v
	}
	cases := []struct {
		V    int
		A, B *uint8
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, Uint8Ptr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestUint16(t *testing.T) {
	cases := []struct {
		V    int
		A, B uint16
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Uint16(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestUint16Ptr(t *testing.T) {
	to := func(v uint16) *uint16 {
		return &v
	}
	cases := []struct {
		V    int
		A, B *uint16
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, Uint16Ptr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestUint32(t *testing.T) {
	cases := []struct {
		V    int
		A, B uint32
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Uint32(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestUint32Ptr(t *testing.T) {
	to := func(v uint32) *uint32 {
		return &v
	}
	cases := []struct {
		V    int
		A, B *uint32
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, Uint32Ptr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestUint64(t *testing.T) {
	cases := []struct {
		V    int
		A, B uint64
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Uint64(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestUint64Ptr(t *testing.T) {
	to := func(v uint64) *uint64 {
		return &v
	}
	cases := []struct {
		V    int
		A, B *uint64
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, Uint64Ptr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestByte(t *testing.T) {
	cases := []struct {
		V    int
		A, B byte
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Byte(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestBytePtr(t *testing.T) {
	to := func(v byte) *byte {
		return &v
	}
	cases := []struct {
		V    int
		A, B *byte
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, BytePtr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestRune(t *testing.T) {
	cases := []struct {
		V    int
		A, B rune
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Rune(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestRunePtr(t *testing.T) {
	to := func(v rune) *rune {
		return &v
	}
	cases := []struct {
		V    int
		A, B *rune
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, RunePtr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestFloat32(t *testing.T) {
	cases := []struct {
		V    int
		A, B float32
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Float32(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestFloat32Ptr(t *testing.T) {
	to := func(v float32) *float32 {
		return &v
	}
	cases := []struct {
		V    int
		A, B *float32
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, Float32Ptr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}

func TestFloat64(t *testing.T) {
	cases := []struct {
		V    int
		A, B float64
	}{
		{0, 10, 10},
		{-1, 10, 100},
		{1, 100, 10},
	}
	for _, c := range cases {
		assert.Equalf(t, c.V, Float64(c.A, c.B), "%v <=> %v", c.A, c.B)
	}
}

func TestFloat64Ptr(t *testing.T) {
	to := func(v float64) *float64 {
		return &v
	}
	cases := []struct {
		V    int
		A, B *float64
	}{
		{0, nil, nil},
		{0, to(10), to(10)},
		{-1, to(10), to(100)},
		{1, to(100), to(10)},
	}
	for _, c := range cases {
		assert.NotPanicsf(t, func() {
			assert.Equalf(t, c.V, Float64Ptr(NilFirst)(c.A, c.B), "%v <=> %v", c.A, c.B)
		}, "%v <=> %v", c.A, c.B)
	}
}
